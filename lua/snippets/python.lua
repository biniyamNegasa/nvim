local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node

return {
  s("ufclass", {
    t({
      "class UF:",
      "    def __init__(self, n):",
      "        self.par = [i for i in range(n)]",
      "        self.rank = [1] * n",
      "",
      "    def find(self, x):",
      "        while x != self.par[x]:",
      "            self.par[x] = self.par[self.par[x]]",
      "            x = self.par[x]",
      "        return x",
      "",
      "    def union(self, x, y):",
      "        par_x = self.find(x)",
      "        par_y = self.find(y)",
      "",
      "        if par_x == par_y:",
      "            return False",
      "",
      "        if self.rank[par_x] >= self.rank[par_y]:",
      "            self.par[par_y] = par_x",
      "            self.rank[par_x] += self.rank[par_y]",
      "        else:",
      "            self.par[par_x] = par_y",
      "            self.rank[par_y] += self.rank[par_x]",
      "",
      "        return True",
    }),
  }),

  s("segtclass", {
    t({
      "class SegT:",
      "    def __init__(self, nums):",
      "        self.nums = nums",
      "        self.n = len(nums)",
      "        self.tree = [0] * (2 * self.n)",
      "        self.build()",
      "",
      "    def build(self):",
      "        for i in range(self.n):",
      "            self.tree[i + self.n] = self.nums[i]",
      "",
      "        for i in range(self.n - 1, 0, -1):",
      "            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]",
      "",
      "    def update(self, index, val):",
      "        self.tree[index + self.n] = val",
      "        self.nums[index] = val",
      "        index += self.n",
      "        while index > 1:",
      "            self.tree[index >> 1] = self.tree[index] + self.tree[index ^ 1]",
      "            index >>= 1",
      "",
      "    def range_sum(self, left, right):",
      "        tot = 0",
      "        left += self.n",
      "        right += self.n",
      "",
      "        while left < right:",
      "            if left & 1:",
      "                tot += self.tree[left]",
      "                left += 1",
      "",
      "            if right & 1:",
      "                right -= 1",
      "                tot += self.tree[right]",
      "",
      "            left >>= 1",
      "            right >>= 1",
      "",
      "        return tot",
    }),
  }),
  s("bitclass", {
    t({
      "class BIT:",
      "    def __init__(self, nums):",
      "        self.n = len(nums)",
      "        self.tree = [0] * (self.n + 1)",
      "        self.nums = nums",
      "",
      "        for i in range(self.n):",
      "            temp = self.nums[i]",
      "            self.nums[i] = 0",
      "            self.update(i, temp)",
      "",
      "    def update(self, index, val):",
      "        org = self.nums[index]",
      "        self.nums[index] = val",
      "",
      "        delta = val - org",
      "",
      "        index += 1",
      "",
      "        while index < self.n + 1:",
      "            self.tree[index] += delta",
      "            index += index & -index",
      "",
      "    def query(self, index):",
      "        index += 1",
      "        curr = 0",
      "        while index:",
      "            curr += self.tree[index]",
      "            index -= index & -index",
      "",
      "        return curr",
      "",
      "    def range_sum(self, left, right):",
      "        return self.query(right) - self.query(left - 1)",
    }),
  }),
}
