local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node

return {
  s("sparsetclass", {
    t({
      "class SparseT:",
      "    def __init__(self, nums, f=max, p=0):",
      "        k = 25",
      "        n = len(nums)",
      "        self.st = [[p] * n for _ in range(k + 1)]",
      "        self.st[0] = nums[:]",
      "        self.f = f",
      "",
      "        for i in range(1, k + 1):",
      "            for j in range(n - (1 << i) + 1):",
      "                self.st[i][j] = self.f(",
      "                    self.st[i - 1][j], self.st[i - 1][j + (1 << (i - 1))]",
      "                )",
      "",
      "    def get(self, left, right):",
      "        i = (right - left).bit_length() - 1",
      "        return self.f(self.st[i][left], self.st[i][right - (1 << i)])",
    }),
  }),
  s("ufclass", {
    t({
      "class UF:",
      "    def __init__(self, n):",
      "        self.par = [i for i in range(n)]",
      "        self.rank = [1] * n",
      "",
      "    def find(self, x):",
      "        while x != self.par[x]:",
      "            self.par[x] = self.par[self.par[x]]",
      "            x = self.par[x]",
      "        return x",
      "",
      "    def union(self, x, y):",
      "        par_x = self.find(x)",
      "        par_y = self.find(y)",
      "",
      "        if par_x == par_y:",
      "            return False",
      "",
      "        if self.rank[par_x] >= self.rank[par_y]:",
      "            self.par[par_y] = par_x",
      "            self.rank[par_x] += self.rank[par_y]",
      "        else:",
      "            self.par[par_x] = par_y",
      "            self.rank[par_y] += self.rank[par_x]",
      "",
      "        return True",
    }),
  }),

  s("segtclass", {
    t({
      "class SegT:",
      "    def __init__(self, nums):",
      "        self.nums = nums",
      "        self.n = len(nums)",
      "        self.tree = [0] * (2 * self.n)",
      "        self.build()",
      "",
      "    def build(self):",
      "        for i in range(self.n):",
      "            self.tree[i + self.n] = self.nums[i]",
      "",
      "        for i in range(self.n - 1, 0, -1):",
      "            self.tree[i] = self.tree[i << 1] + self.tree[i << 1 | 1]",
      "",
      "    def update(self, index, val):",
      "        self.tree[index + self.n] = val",
      "        self.nums[index] = val",
      "        index += self.n",
      "        while index > 1:",
      "            self.tree[index >> 1] = self.tree[index] + self.tree[index ^ 1]",
      "            index >>= 1",
      "",
      "    def range_sum(self, left, right):",
      "        tot = 0",
      "        left += self.n",
      "        right += self.n",
      "",
      "        while left < right:",
      "            if left & 1:",
      "                tot += self.tree[left]",
      "                left += 1",
      "",
      "            if right & 1:",
      "                right -= 1",
      "                tot += self.tree[right]",
      "",
      "            left >>= 1",
      "            right >>= 1",
      "",
      "        return tot",
    }),
  }),
  s("bitclass", {
    t({
      "class BIT:",
      "    def __init__(self, nums):",
      "        self.n = len(nums)",
      "        self.tree = [0] * (self.n + 1)",
      "        self.nums = nums",
      "",
      "        for i in range(self.n):",
      "            temp = self.nums[i]",
      "            self.nums[i] = 0",
      "            self.update(i, temp)",
      "",
      "    def update(self, index, val):",
      "        org = self.nums[index]",
      "        self.nums[index] = val",
      "",
      "        delta = val - org",
      "",
      "        index += 1",
      "",
      "        while index < self.n + 1:",
      "            self.tree[index] += delta",
      "            index += index & -index",
      "",
      "    def query(self, index):",
      "        index += 1",
      "        curr = 0",
      "        while index:",
      "            curr += self.tree[index]",
      "            index -= index & -index",
      "",
      "        return curr",
      "",
      "    def range_sum(self, left, right):",
      "        return self.query(right) - self.query(left - 1)",
    }),
  }),
  s("suffixclass", {
    t({
      "class SuffArray:",
      "    @staticmethod",
      "    def counting_sort(suff, equi):",
      "        n = len(suff)",
      "        cc = [0] * n",
      "        for val in equi:",
      "            cc[val] += 1",
      "",
      "        nsuff = [0] * n",
      "        pos = [0] * n",
      "        for i in range(1, n):",
      "            pos[i] = pos[i - 1] + cc[i - 1]",
      "",
      "        for val in suff:",
      "            ind = equi[val]",
      "            nsuff[pos[ind]] = val",
      "            pos[ind] += 1",
      "",
      "        for i in range(n):",
      "            suff[i] = nsuff[i]",
      "",
      "    @staticmethod",
      "    def get_suffix_array(s):",
      "        n = len(s)",
      "        suff = [0] * n",
      "        equi = [0] * n",
      "",
      "        lst = [[s[i], i] for i in range(n)]",
      "        lst.sort()",
      "",
      "        for i in range(n):",
      "            suff[i] = lst[i][1]",
      "",
      "        for i in range(1, n):",
      "            equi[suff[i]] = equi[suff[i - 1]] + 1 - (lst[i][0] == lst[i - 1][0])",
      "",
      "        k = 0",
      "        while (1 << k) < n:",
      "            for i in range(n):",
      "                suff[i] = (suff[i] - (1 << k) + n) % n",
      "",
      "            SuffArray.counting_sort(suff, equi)",
      "",
      "            nequi = [0] * n",
      "            for i in range(1, n):",
      "                curr = [equi[suff[i]], equi[(suff[i] + (1 << k)) % n]]",
      "                prev = [equi[suff[i - 1]], equi[(suff[i - 1] + (1 << k)) % n]]",
      "",
      "                nequi[suff[i]] = nequi[suff[i - 1]] + 1 - (curr == prev)",
      "",
      "            for i in range(n):",
      "                equi[i] = nequi[i]",
      "",
      "            k += 1",
      "",
      "        return suff",
      "",
      "    @staticmethod",
      "    def get_lcp(s, suff):",
      "        n = len(s)",
      "        rank = [0] * n",
      "        for i in range(n):",
      "            rank[suff[i]] = i",
      "",
      "        k = 0",
      "        lcp = [0] * (n - 1)",
      "        for i in range(n):",
      "            if rank[i] == n - 1:",
      "                k = 0",
      "                continue",
      "",
      "            j = suff[rank[i] + 1]",
      "",
      "            while i + k < n and j + k < n and s[i + k] == s[j + k]:",
      "                k += 1",
      "",
      "            lcp[rank[i]] = k",
      "            if k:",
      "                k -= 1",
      "",
      "        return lcp",
    }),
  }),
}
